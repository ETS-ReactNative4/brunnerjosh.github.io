<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Process Scheduling Algorithms - Josh Brunner
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="Front-End Web Developer">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Process Scheduling Algorithms</h1>
        <p class="author">Written by <span class="author">Josh Brunner</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>In my Operating Systems class (<span class="caps">CSS</span> 430), our homework 2 assignment was to implement process scheduling algorithms on top of the school’s ThreadOS. ThreadOS is a emulated operating system based in Java. It was built by the school to help students conceptualize the operations that go on at the OS-level of the&nbsp;computer.</p>
<hr>
<ul>
<li><a href="https://github.com/brunnerjosh/process-scheduling-algorithms">GitHub&nbsp;Repository</a></li>
</ul>
<hr>
<h1 id="purpose">Purpose</h1>
<p>This assignment implements two process scheduling algorithms on top of ThreadOS. The names of the algorithms are the Round Robin and the Multi-Level Feedback Queue. There are a set of test programs that get called to simulate the variable times that some process take to complete execution. At the end of each algorithm section, I present screenshots of the results so that you can see how long each process took to complete execution,&nbsp;etc.</p>
<p>Feel free to read the school’s full spec for this assignment <a href="http://courses.washington.edu/css430/prog/prog2.html">here</a>.</p>
<h1 id="algorithms">Algorithms</h1>
<p>This section will go over the two scheduling algorithms that we implemented in this assignment. Each section contains a screenshot of the performance results. Take note of the <code>execution time</code> in each process’s completed&nbsp;results.</p>
<h2 id="round-robin-suspend-resume-">Round Robin&nbsp;(Suspend/Resume)</h2>
<p>Although <code>suspend()</code> and <code>resume()</code> are deprecated Java methods, we still learned them so that we could compare the performance of the different scheduling&nbsp;algorithms.</p>
<h3 id="performance-results">Performance&nbsp;Results</h3>
<p><img src="https://raw.githubusercontent.com/brunnerjosh/process-scheduling-algorithms/master/images/round-robin-output.png" alt="Performance Results"></p>
<h2 id="multi-level-feedback-queue-mlfq-">Multi-Level Feedback Queue&nbsp;(<span class="caps">MLFQ</span>)</h2>
<p>The <span class="caps">MLQS</span> algorithm utilizes three separate queues (queue0, queue1, and queue2). Each queue serves a slightly separate purpose throughout the scheduler’s&nbsp;use.</p>
<p>Upon being called by the Thread class, the run() function immediately initializes a Thread object to handle the processing of thread objects throughout the execution of the code. It then enters into an indefinite while loop to capture threads being added to&nbsp;queue0.</p>
<p>Queue0 allows threads to execute for timeSlice/2. In this case, timeSlice is defaulted to 1000ms, or 1 second. If the process hasn’t completed execution within the allotted 500ms, the process is moved to&nbsp;queue1.</p>
<p>Queue1 allows the process to execute for another 500ms and then checks to see if any new process has been added. If a new process has indeed been added to queue0, it jumps up to process that appropriately. If not, it lets the original process run for another&nbsp;500ms.</p>
<p>If this process still hasn’t completed, it is moved to queue2 where it is allowed to run for a total of 2000ms until it is removed from the top of queue2 and added to the bottom. Queue2 follows similar scenario handling in the event of a new process being added to either queue0 or queue1 after it’s for 500ms are&nbsp;used.</p>
<p><em>Please see the flowchart section below for a visual description of the multi-level queue scheduling&nbsp;algorithm</em></p>
<h3 id="performance-results">Performance&nbsp;Results</h3>
<p><img src="https://raw.githubusercontent.com/brunnerjosh/process-scheduling-algorithms/master/images/mlfq-output.png" alt="Performance Results"></p>
<h3 id="flowchart">Flowchart</h3>
<p><img src="https://raw.githubusercontent.com/brunnerjosh/process-scheduling-algorithms/master/images/mlqs-flowchart.jpg" alt="Flow Chart"></p>
<h1 id="execution-chart">Execution&nbsp;Chart</h1>
<p>This chart shows a breakdown of the processes (Pa, Pb, Pc, Pd, Pe, Test2, and the Scheduler) over the course of their completion while in the <span class="caps">MLFQ</span>.
<img src="https://raw.githubusercontent.com/brunnerjosh/process-scheduling-algorithms/master/images/mlfq-algorithm-process.png" alt="Execution Chart"></p>
<h1 id="discussion">Discussion</h1>
<p>By utilizing three separate queues with three separate time quantum, the <span class="caps">MLQS</span> algorithm appears to have outperformed the Round Robin (suspend/resume) algorithm quite greatly. In the Comparison Results section below, you can see that the green boxes show improvement in processing while red boxes show decreases in processing when the MLQS algorithm is used against&nbsp;Test2.java.</p>
<p>The reason the <span class="caps">MLQS</span> performs better than the RR (suspend/resume) algorithm is because most of the processes start and finish within 2 queues. The rest get pushed down to the third queue (queue2), where larger timeSlices allow for large chunks of their CPU burst to be&nbsp;processed.</p>
<h2 id="comparison-results">Comparison&nbsp;Results</h2>
<p><img src="https://raw.githubusercontent.com/brunnerjosh/process-scheduling-algorithms/master/images/comparison-chart.png" alt="Comparison Results"></p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="about"><p>Josh holds a CSSE (Computer Science and Software Engineering) degree from The University of Washington. In his spare time, he pursues  photography using his DSLR and posts his favorites on his <a href="https://www.flickr.com/photos/77226941@N04/">Flickr</a> account. Currently, he works for a company located in Seattle called <a href="http://www.helpfulhuman.com/">Helpful Human</a> as a Front-End Web Developer. If you’d like to contact him, his email address is <a href="mailto:joshuaebrunner@gmail.com">joshuaebrunner@gmail.com</a>.</p>

        </section>
        <section class="copy">
          <p>&copy; 2015 Josh Brunner &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>