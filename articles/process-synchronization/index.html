<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Process Synchronization - Josh Brunner
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="Front-End Web Developer">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Process Synchronization</h1>
        <p class="author">Written by <span class="author">Josh Brunner</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>This assignment’s purpose was to exercise the implementation of Java monitors. Specifically, the assignment had us preempt threads that were for disk read/write operations and instead allow another thread to execute. This inherently prevents the I/O-bound threads from wastefully using <span class="caps">CPU</span> power when other tasks could be getting completed. This was accomplished by using <code>SysLib.wait()</code> and <code>SysLib.exit()</code> calls to sleep threads and wake them when their child thread had&nbsp;completed.</p>
<hr>
<ul>
<li><a href="https://github.com/brunnerjosh/process-synchronization">GitHub&nbsp;Repository</a></li>
<li><a href="http://courses.washington.edu/css430/prog/prog3.html">Project&nbsp;Specification</a></li>
</ul>
<hr>
<h1 id="part-1">Part&nbsp;1</h1>
<p>The first part of the assignment deals with two programs, SyncQueue and QueueNode. Each program works towards the common effort of enabling threads to be able to wait for a child thread to be terminated before further execution is completed. This, in turn, is a form of implementation of Java monitors. The two paragraphs below will discuss each program’s algorithm more&nbsp;specifically.</p>
<h2 id="syncqueue">SyncQueue</h2>
<p>This program is used to prevent threads from busy waiting on disk read and write operations. It accomplishes this by constructing a list (array) of QueueNode objects upon construction. Once created, SyncQueue provides two means of adding and removing from this array. Depending on the condition variable sent into either “enqueueAndSleep()” or “dequeueAndWakeup(),” the QueueNode at the location in the array is slept or woken, using sleep() and wakeup(),&nbsp;respectively.</p>
<h2 id="queuenode">QueueNode</h2>
<p>This short program is used to call the wait() and notify() methods in certain circumstances. When constructed, a new Vector called “queue” is created to hold integers that represent the waiting thread’s <span class="caps">ID</span> (tid). Within QueueNode’s two main functions, sleep() and wakeup(), the thread is able to put itself to sleep while in a critical section of&nbsp;code.</p>
<h2 id="part-1-results">Part 1&nbsp;Results</h2>
<p>The assignment was&nbsp;to:</p>
<pre><code>&gt; Compile your SyncQueue.java and Kernel.java, and thereafter run Test2.java
&gt; from the Shell.class to confirm:
&gt; 1. Test2.java waits for the termination of all its five child threads,
&gt; (i.e., the TestThread2.java threads).
&gt; 2. Shell.java waits for the termination of Test2.java. Shell.java should
&gt; not display its prompt until Test2.java has completed its execution.
&gt; 3. Loader.java waits for the termination of Shell.java. Loader.java should
&gt; not display its prompt ( --&gt; ) until you type exit from the Shell prompt.
</code></pre><p>Below is a screenshot of running Test2.java per the expected&nbsp;results:</p>
<p><img src="https://raw.githubusercontent.com/brunnerjosh/process-synchronization/master/images/test2_output.png" alt="Test 2 Results"></p>
<h1 id="part-2">Part&nbsp;2</h1>
<p>The second part of this assignment was to write a user-level test thread called <code>Test3.java</code> which spawns and waits for the competition of a certain number of threads. These test threads are supposed to do numerical computation (<code>TestThread3a.java</code>) as well as random read/write operations to the disk (<code>TestThread3b.java</code>).</p>
<h2 id="test3">Test3</h2>
<p>This program is interesting. It is written in a way that puts the <span class="caps">CPU</span>’s processing power to stressful boundaries. Upon creation, the user is expected to have their desired X value loaded into argv[0]. With this number, Test3 spins up X amount of pairs of threads. The threads can be either a numerical computation task or a disk READ/WRITE task. Both of these tasks are completely pointless with respect to getting actual work done, there are simply made to demonstrate how an effective use of sleeping and waking processes is done. Once Test3 has executed these threads, it spins in two different loops so that the threads may join() when they&nbsp;complete.</p>
<h2 id="testthread3a">TestThread3a</h2>
<p>This is one of the threads that Test3 spins up. It invokes very complex mathematical calculations including recursive factorials, square roots, and finding the tangent. It does all this in an n^2 manner with two for&nbsp;loops.</p>
<h2 id="testthread3b">TestThread3b</h2>
<p>As the second of the threads, this thread reads and writes maximum blocks of bytes to the <span class="caps">DISK</span> in the folder. Once gain, a complete waste of resources but used to demonstrate how program 3 handles this kind of&nbsp;work.</p>
<h2 id="part-2-results">Part 2&nbsp;Results</h2>
<p>Below is a screenshot of running Test3.java on kernel_1.java (implemented in Part 1):
<img src="https://raw.githubusercontent.com/brunnerjosh/process-synchronization/master/images/kernel_1_output.png" alt="Kernel 1 Results"></p>
<p>Below is a screenshot of running Test3.java on kernel.java (implemented in Part 2):
<img src="https://raw.githubusercontent.com/brunnerjosh/process-synchronization/master/images/kernel_2_output.png" alt="Kernel 2 Results"></p>
<h2 id="comparison">Comparison</h2>
<p>As shown in the screenshots above, the later is the clear winner. Completing Test3’s complex tasks more than 4 seconds faster proves the revised kernel.java to be the better kernel program. But of course doing simply one test is not enough to determine a faster program. Therefore, I tested each kernel alongside each other in a head-to-head race with the X variable at different numbers. You can see the results in the diagrams&nbsp;below.</p>
<p><img src="https://raw.githubusercontent.com/brunnerjosh/process-synchronization/master/images/performance-results.png" alt="Kernel 2 Results"></p>
<p>From this data, I learned that there are a lot of factors that can effect the outcome of these tests. It appears that the percentage increase can vary greatly depending on the other <span class="caps">CPU</span> tasks and other factors that I might not be aware of. I believe these results might be more prominent had I been working on a dual core CPU. In the end, this data concludes that the kernel.java, which was modified to allow threads to sleep on disk operations, performs better than the kernel.java (kernel_1.java) which does&nbsp;not.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="about"><p>Josh holds a CSSE (Computer Science and Software Engineering) degree from The University of Washington. In his spare time, he pursues  photography using his DSLR and posts his favorites on his <a href="https://www.flickr.com/photos/77226941@N04/">Flickr</a> account. Currently, he works for a company located in Seattle called <a href="http://www.helpfulhuman.com/">Helpful Human</a> as a Front-End Web Developer.</p>

        </section>
        <section class="copy">
          <p>&copy; 2015 Josh Brunner &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>