<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Disk Caching - Josh Brunner
    </title>
    <link rel="alternate" href="http://localhost:8080/feed.xml" type="application/rss+xml" title="Front-End Web Developer">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Disk Caching</h1>
        <p class="author">Written by <span class="author">Josh Brunner</span>
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>The fourth homework assignment in my operating systems class at <span class="caps">UW</span> was to implement disk caching based on the algorithm known as the Second Chance Algorithm (SCA). After completing the assignment, I measured the performance and provided screenshots to view the&nbsp;results.</p>
<hr>
<ul>
<li><a href="https://github.com/brunnerjosh/disk-caching">GitHub&nbsp;Repository</a></li>
<li><a href="http://courses.washington.edu/css430/prog/prog4.html">Project&nbsp;Specification</a></li>
</ul>
<hr>
<h1 id="specification">Specification</h1>
<p>Cache.java is a program that I wrote to implement disk caching based on an algorithm called the Second Chance Algorithm (<span class="caps">SCA</span>). As with many caching programs, my Cache.java follows the conventional methods to perform reads/write/syncs/flushes. Cache.java uses the SCA to accomplish the task of finding a “victim” block in cache. This “victim” block is defined as the block that has not been referenced recently. As blocks are mutated in the read and write functions, their reference bit is updated to reflect the fact they they were recently referenced. A detailed description of the SCA, Read, and Write can be found&nbsp;below.</p>
<h2 id="second-chance-algorithm">Second Chance&nbsp;Algorithm</h2>
<p>It loops through the cache over and over until it finds a victim <span class="caps">ID</span>. The basic description of the algorithm is as follows: Starting at the beginning of the array, check each block’s reference bit. If the reference bit is not set (meaning it hasn’t been recently used), return this as the victim. If the reference bit is set (the block has been recently used), move onto the next block in a circular fashion. However, before leaving that last block, mark its reference bit to false (hasn’t been recently used), effectively giving the block a second&nbsp;chance.</p>
<h2 id="read">Read</h2>
<p>After ensuring that read() is handed a valid blockId from disk, it looks to see if the blockId is already in Cache. If so, it reads the data from the cache at that blockId’s location. If the blockId was not found (returned <span class="caps">INVALID</span>), it searches the cache for an empty blockId. If found, data is first read from disk into cache, then that data is read from cache to the accompanying buffer. If this empty search did not find an empty blockId, the Second Chance algorithm is used in order to find a victim blockId to be read into and read from. If all worked well, this function returns true, otherwise&nbsp;false.</p>
<h2 id="write">Write</h2>
<p>After ensuring that write() is handed a valid blockId from disk, it looks to see if the blockId is already in Cache. If so, it writes the data from the buffer at that blockId’s location into cache. If the blockId was not found (<span class="caps">INVALID</span>), it searches the cache for an empty blockId. If found,the data is read from buffer into cache at the empty blockId’s location.If this empty search did not find an empty blockId, the Second Chance algorithm is used in order to find a victim blockId to be write into. If all worked well, this function returns true, otherwise&nbsp;false.</p>
<h2 id="performance-results">Performance&nbsp;Results</h2>
<p>Below are the results of running my Test4 program using the Second Chance Algorithm caching implementation on&nbsp;ThreadOS.</p>
<p>There are four tests that Test4 can do to test ThreadOS’s caching mechanism. Within the source code of Test4.java, a detailed description of the what the test effectively does is&nbsp;explained.</p>
<h2 id="test-1-random-accesses">Test 1: Random&nbsp;Accesses</h2>
<p>a. Cache <em>Enabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test1_enabled.jpg" alt="Cache Enabled"></p>
<p>b. Cache <em>Disabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test1_disabled.jpg" alt="Cache Disabled"></p>
<h2 id="performance-consideration">Performance&nbsp;Consideration</h2>
<p>The improvement from [en/dis]abling the cache when doing randomized accesses is not too apparent in terms of increasing performance. There does seem to be a slight increase in overall write speed with a decrease in read speed when cache is enabled but nothing groundbreaking. This is likely due to the fact that blocks are randomly created and accessed. I expect that these mainly performed in an adverse&nbsp;manner.</p>
<h2 id="test-2-random-accesses">Test 2: Random&nbsp;Accesses</h2>
<p>a. Cache <em>Enabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test2_enabled.jpg" alt="Cache Enabled"></p>
<p>b. Cache <em>Disabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test2_disabled.jpg" alt="Cache Disabled"></p>
<h2 id="performance-consideration">Performance&nbsp;Consideration</h2>
<p>The improvement from [en/dis]abling the cache when doing localized accesses is <span class="caps">HUGE</span>. When cache is enabled, since all referenced blocks are loaded into cache, the ability for the blocks to read and be written to is drastically increased. When cache is disabled, even though the blocks being written/read to are close by, the disk is forced to do multiple raw reads and rawwrites over and over. This is a great example of using disk caching to speed up localized&nbsp;accesses.</p>
<h2 id="test-3-random-accesses">Test 3: Random&nbsp;Accesses</h2>
<p>a. Cache <em>Enabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test3_enabled.jpg" alt="Cache Enabled"></p>
<p>b. Cache <em>Disabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test3_disabled.jpg" alt="Cache Disabled"></p>
<h2 id="performance-consideration">Performance&nbsp;Consideration</h2>
<p>The improvement from [en/dis]abling the cache when doing mixed accesses is significant. Since, by nature, mixed accesses include 90% localized access and 10% random access, there’s going to be performance increases. I’ve already proved that localized access is drastically increased when cache is enabled. On the contrary, it doesn’t seem to matter at all if cache is enabled/disabled for random accesses. Therefore, the difference in enabling/disabling the cache for mixed accesses is a result of the performance in localized&nbsp;accesses.</p>
<h2 id="test-4-random-accesses">Test 4: Random&nbsp;Accesses</h2>
<p>a. Cache <em>Enabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test4_enabled.jpg" alt="Cache Enabled"></p>
<p>b. Cache <em>Disabled</em>
<img src="https://raw.githubusercontent.com/brunnerjosh/disk-caching/master/images/test4_disabled.jpg" alt="Cache Disabled"></p>
<h2 id="performance-consideration">Performance&nbsp;Consideration</h2>
<p>The improvement from [en/dis]abling the cache when doing adversary accesses is not significant. Whether cache is enabled or not does not seem to change the output by much. Similar to the results seen in Random Access, Adverse Access is slightly faster when cache is enabled for writing, however, and slightly slower for reading. This is the result of not using the same blocks in reading/writing at&nbsp;all.</p>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="about"><p>Josh holds a CSSE (Computer Science and Software Engineering) degree from The University of Washington. In his spare time, he pursues  photography using his DSLR and posts his favorites on his <a href="https://www.flickr.com/photos/77226941@N04/">Flickr</a> account. Currently, he works for a company located in Seattle called <a href="http://www.helpfulhuman.com/">Helpful Human</a> as a Front-End Web Developer. If you’d like to contact him, his email address is <a href="mailto:joshuaebrunner@gmail.com">joshuaebrunner@gmail.com</a>.</p>

        </section>
        <section class="copy">
          <p>&copy; 2015 Josh Brunner &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
  </body>
</html>